# vector со small-object и copy-on-write оптимизациями

В этом задании необходимо реализовать класс аналогичный `std::vector`, но
имеющий *small-object* и *copy-on-write* оптимизации.

*small-object* предполагает, что вектор умеет хранить небольшое число элементов
без динамической аллокации памяти.

*copy-on-write* предполагает, что
копирование/присваивание больших векторов не копирует все элементы само, а
откладывает копирование элементов до момента когда к объекту применят
модифицирующую операцию.

Реализуемый класс должен называться `socow_vector` и лежать в
хедере `socow-vector.h`. Он должен иметь два шаблонных параметра: тип хранимых
объектов и размер маленького буффера.

```cpp
template <typename T, size_t SMALL_SIZE>
class socow_vector;
```

Из-за наличия  *small-object* и *copy-on-write* оптимизаций, некоторые операции
имеют другую вычислительную сложность и/или предоставляют другую гарантию
безопасности исключений:

* Конструктор копирования и оператор присваивания должны работать
  за `O(SMALL_SIZE)`, а не за `O(size)`.
* Если размеры и `a` и `b` не больше `SMALL_SIZE`, `swap(a, b)` должен
  предоставлять базовую гарантию безопасности исключений, иначе – сильную.
* Если размеры и `a` и `b` не больше `SMALL_SIZE`, `a = b` должен предоставлять
  базовую гарантию безопасности исключений, иначе – сильную.
* Неконстантные
  операции `operator[]`, `data()`, `front()`, `back()`, `pop_back()`, `begin()`,
  `end()` должны работать за O(size) и удовлетворять сильной гарантии
  безопасности исключений, если требуется копирование для *copy-on-write*, и за
  O(1) и nothrow иначе.
* Как и со стандартным вектором, `reserve` должен гарантировать, что после
  выполения `reserve(n)` вставки в вектор не будут приводить к переаллокациям,
  пока размер <= `n`.

