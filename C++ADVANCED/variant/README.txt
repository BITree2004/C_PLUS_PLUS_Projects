# variant

Интерфейс, все свойства и гарантии должны соответствовать [std::variant](https://en.cppreference.com/w/cpp/utility/variant). Специализацию `std::hash` писать не надо.
По аналогии с заданием `optional`, требуется по возможности сохранять тривиальности для [special member functions](https://en.cppreference.com/w/cpp/language/member_functions#Special_member_functions). Также стоит уделить внимание правильности расстановки `noexcept`.

## Conversion

Обратите внимание на описание на cppreference для converting конструктора/operator=, которое прямо говорит, как их реализовывать. Такой код должен работать ожидаемым образом:
```cpp
variant<string, bool> x = "abc"; // holds string
```

Но проблема в том, что указатель `char const*` приводится как к `bool`, так и к `string `. Изначально для этого в стандарте сделали небольшой "костыль" в [P0608R3](https://wg21.link/p0608r3), по сути обработав специально ситуацию с конвертацией к bool (см. статью). Это иногда ведёт себя [неожиданным образом](https://wg21.link/lwg3228), но пример выше благодаря такому работает.

Потом конверсию к `bool` признали *narrowing*: [P1957R2](https://wg21.link/p1957r2), а такие конверсии запрещены в константных выражениях. В том же предложении убрали "костыль" для конструктора variant'а: теперь то, что отсекалось им, должно отсекаться из-за *narrowing conversion*, и он больше не нужен.  
